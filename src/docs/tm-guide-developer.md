# Руководство по разработке для топик менеджера (tm, topic manager)

## Работа с правилами

### 1. Общий принцип

Есть два метода взаимодействия с TM - автоматический и ручной.
Основным методом взаимодействия является автоматический, в котором
все действия пользователя взаимодействующего с wb-rules должны
проксироваться через TM. В этом случае последовательность работы такая.

1. Есть две главных типа сущности которые сохраняют информацию
   - Один реестр всех топиков с которыми идет работа в скрипте
   - Два реестра правил - общий и сервисный
     Все правила которые созданы в скрипте должны быть добавлены либо в однин
     либо во второй реестр.
2. Пользователь сначала конфигурирует то чего хочет делать, например
   регистрирует события - что приводит к добавлению топиков в реестр топиков.
3. После конфигурирования вызывается `tm.initRulesForAllTopics('RuleName');`
   Этот метод создает одно правило в общий реестр и одно правило
   в сервисный реестр.
   - Каждое из правил вызывается при изменении любого из топиков в TM
   - При вызове правило вызывает запуск цепочки процессоров куда добавляют
     свои процессоры плагины.

   Функия в правилах выглядит следующим образом:

   ```javascript
   function (newValue, devName, cellName) {
     var topic = devName + '/' + cellName;
     this.runProcessors(topic, newValue);
   }
   ```

4. Внутри цепочки процессоров последовательно вызываются все процессоры
   которые были добавлены туда плагинами в соответствии с приоритетами.

   Порядок вызова сервисного или обычного реестра правил не гарантируется
   так как для этого нет инструментов в wb-rules.

Таким образом - после вызова `initRulesForAllTopics` в независимости от
используемого колличества топиков или установленных плагинов, в простом
случае всегда создается всего два правила, а вся обработка идет уже внутри
этих двух правил.

Сервисный реестр правил нужно использовать только по необходимости,
вынося туда только обработку сервисных функций - например события
переключателя для управления исполнением правил в винтуальном
устройстве TM вынесено в сервисный реестр из за того что оно должно
продолжить работать после отключения всех правил, иначе потом будет
невозможно включить пользовательские правила обратно.

### 2. Инструменты

Внутренний метод `_defineTmRule()` позволяет определять правило wb-rules
и возвращает объект описывающий правило. Данный объект далее может быть
записан в один из двух реестров.

Есть два метода которые нужно использовать как внутри TM так и снаружи для
добавления правил в один из реестров:

- `_defineAndStoreTmRule()` -> внешне называется `tm.defineRule()`
- `_defineAndStoreServiceTmRule()` -> внешне `tm.defineServiceRule()`

При использовании `initRulesForAllTopics(ruleName)` внутри каждого реестра
создается правило для обработки цепочки обработки данных которые вызываются
при изменении любого из зарегистрированных в TM топиков.

Плагины могут добавлять свои обработчики как один так и во второй
обработчики. Например плагин базового виртуального девайса добавляет
правило в сервисный обработчик для обработки изменения состояния
переключателя разрешения обработки правил пользователя.

## Плагины

Так как кроме событий и истории значений для реализации сложных действий
может потребоваться хранить другие данные в реестр топиков или захочется
добавить новые методы работы с топиками, то реализована система плагинов
которые можно подключать при необходимости и писать свои плагины дополняя
возможности Topic Manager.

Система плагинов выбрана и реализована похожей на vue js.
Плагины подключаются к уже созданному экземпляру топик менеджера и добавляют
в этот объект новые методы, модифицируют или заменяют существующие.

### Возможности плагинов

1) Добавление общих методов обработки - хелперов в объект топик менеджера
2) Добавление процессоров в pluginsProcessorsChain[] который вызывается
   при обработке новой информации
3) Добавление полезной информации о работе топика в реестр топиков (topics)

### Пример подключения

```javascript
// 1. Подключаем базовый модуль и расширения
var TopicManager = require('tm-main.mod').TopicManager;
var eventPlugin = require('tm-event-main.mod').eventPlugin;
var historyPlugin = require('tm-history-main.mod').historyPlugin;

// 2. Создаём инстанс topicManager
var tm = new TopicManager();

// 3. Добавляем расширения
tm.installPlugin(historyPlugin); // подключаем историю значений
tm.installPlugin(eventPlugin); // подключаем event-функции
```

### Структура плагинов

Каждый плагин должен иметь:

1. **Главный файл**
   Именуется по шаблону `tm-<!plugin-name!>-main.mod.js`
   Эот файл должен содержать функцию установки плагина и главную логику

2. **Документация** в формате markdown
   Именуется по шаблону `tm-<!plugin-name!>-guide.md`
   Данный файл должен содержать описание смысла данного плагина, а так же
   все что необходимо для его использования

3. **Дополнительные файлы** (опционально)
   Могут быть названы подобным образом, где начало именуется
   по шаблону `tm-<!plugin-name!>-<!file-name!>.mod.js`
   Например для плагина событий с главномым файлом `tm-event-main.mod.js`
   Можно добавить файл с именем `tm-event-resolvers.mod.js`

Содержание минимального главного файла плагина:

- Функция `install()` - которая вызовется при установке плагина
  Данная функция должна иметь прототип:
  
  ```javascript
  function install(manager, options) {
    
    ... Логика ...
    
    log.debug('TM: Plugin "Event" successfully installed');
  }
  ```

  Где `manager` это экземпляр TopicManager, а `options` - не обязательные
  параметры инициализации, например глубина истории в плагине `history`.
  Обратите внимание на обязательное дебаг сообщение в случае успешной
  установки плагина.

- Экспортированный объект плагина содержащий следущую структуру
  
  ```javascript
  exports.eventPlugin = {
    name: 'eventPlugin',
    install: install,
    dependencies: ['historyPlugin']
  };
  ```

  Где обязательным полем является `name` - имя плагина, которое используется
  для разрешения зависимостей, вывода ошибок, лога и тд.

Дополнительно плагин может зарегистрировать свой процессор в цепочке
обработки. В этом случае плагин добавит дополнительный шаг автоматической
обработки каждого обрабатываемого топика.
Например можно добавить автоматическое сохранение нового значения в историю
значений топика.

```javascript
@file plugin-file.mod.js

...
install() {
  // Напишем функцию процессора которую хотим вставить
  processEvent(...){
    ...Описание логики...
  }

  // Добавим обработчик событий в цепочку процессоров TopicManager
  manager.addProcessor(processEvent);
}
```

### Гибкая цепочка процессоров

Плагин может быть написан двумя способами:

- Добавлять абстрактные методы и поля в реестр которые пользователь использует
  самостоятельно там где ему нужно. Например кастомный логгер.
- Так же может иметь обработчик который будет вставлен в общий обработчик
  обновлений топиков. Например для подсчета статистик постоянной работы.

Общий обработчик - это одна фунция в базовом объекте созданный так чтобы
плагины могли добавлять в нее свои элементы обработки в определенном порядке.

в нашей системе мы знаем только имя топика и новое значение
в базовом элементе должна быть какая то функция которая будет вызываться когда приходит новое значение какого то топика - и вот в этой функции должна быть какая то обработка всех плагинов - например если человек уже написал код раньше и появился новый плагин какой то статистики - например колличество обновлений топика - то он просто включает плагин и вызываемый обработчик в том месте где его вставил пользователь сам меняется и дополняется логикой плагина

В итоге каждый плагин может добавлять новые процессоры которые будут вызваны при обработке новых значений

#### Приоритеты процессоров

Каждый плагин добавляя новый процессор должен указать приоретет в котором он
должен выполниться.

Это важно как для быстродействия, так и для порядка выполнения логики плагинов
ведь один плагин, например обработчик событий должен быть вызван после других
плагинов информацию которых он может использовать, например после плагина
сохранения информации в историю значений топика. А статистика может иметь
необходимость вызванной после обработки событий.

### Два варианта использования

1. Ручное управление обработкой вставляя там где нужно в правила wb-rules
2. Автоматическое создание правила из добавленных в реестр топиков - создает
   одно правило для всех топиков и обрабатывает их плагинами. В этом случае
   правило wb-rules создается топик менеджером и пользователь не должен думать
   об этом. Этот вариант преоритетен если вы не знаете что хотите.

## Написание плагина

Самый простой плагин ниже
```javascript
/**
 * @file tm-event-main.mod.js
 * @description Плагин TM для обработки разных именованных событий топиков
 */

/**
 * Устанавливает плагин событий
 * 
 * @param {Object} manager Экземпляр TopicManager
 * @param {Object} [options] Опциональные параметры
 */
function install(manager, options) {

  /**
    * Логирование состояния реестра
    */
  function logRegistry() {
    var prefix = options && options.prefix ? options.prefix + ' ' : '';
    log.info(prefix + 'Current Registry:');
    if (Object.keys(manager.topics).length === 0) {
      log.info(prefix + 'Registry is empty');
    } else {
      log.info(prefix + JSON.stringify(manager.topics, null, 2));
    }
  }

  /**
    * Обработчик события
    * 
    * @param {string} topic - Имя топика
    * @param {*} newValue - Новое значение топика
    */
  function handleEvent(topic, newValue) {
    log.info('EventPlugin: Handling event for topic:', topic, 'with value:', newValue);

    // @todo: Точка для обработки событий
  }

  manager.addProcessor(handleEvent, options && options.priority || 5);

  manager.logRegistry = logRegistry;
}
  
exports.eventPlugin = {
  name: 'eventPlugin',
  install: install
};
```
