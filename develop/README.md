# Документация для разработчиков

В данном файле описано все что нужно знать для разработки
новых сценариев для WB с нуля.

Информация по другим аспектам работы со сценариями собрана тут:

1. [Пример добавления сценария](example-add-new-scenario.md)
2. [Описание используемого стиля и окружения](environment-guide.md)
   Обязательно использовать форматтер prettier, чтобы следить за форматом кода
   По желанию можно использовать линтер ESLint, чтобы подсвечивать ошибки
3. [Варианты установки и сборки сценариев](install-variants-and-build-pkg.md)

## Общее о сценариях

Сценарии являются методом упрощения конфигурирования контроллера WB.
Они позволяют настраивать работу частых юзкейсов через графический интерфейс
без необходимости изучения написания скриптов.

Сценарии состоят из 4 составляющих

1. Описание WEBUI в виде схемы json-editor: `*.schema.json`
   При необходимости изображения `*.png`

2. Сохраненный конфиг из вебки в виде json структуры: `*.conf`

3. Файл правил `*.js`
   Это точка входа в логику исполнения сценариев, он содержит:

   - Чтение конфигурации из файла
   - Логику парсинга и подготовки данных для инициализации (если она нужна)
   - Вызов методов которые инициализируют виртуальные устрйоства и правила

4. Модуль `*.mod.js`
   Это опциональная единица для возможности использования из скриптов.
   Сюда можно перенести метод init и другую логику.

   ВАЖНО - если пишется модуль - то нужно стараться делать его так,
   чтобы он не занал что работает в сценариях:
   Он должен принимать общие структуры данных - например массивы входных
   и выходных контролов, но не объект самого сценария. Это нужно чтобы
   его можно было использовать вообще без сценариев, там где конфиг имеет
   другую структуру.

Ниже описывается процесс создания новых сценариев

## Добавление нового сценария

Для добавления нового сценария нужно выполнить несколько шагов:

1. Создать в папке `scenarios` подпапку с именем вашего сценария.
   Имя маленькими латинскими буквами через тире, например `link-in-to-out`
   Тут хранятся файлы относяшиеся к конкретному сценарию:

   - Модуль js `*.mod.js`
   - Скрипт `init-*.js` читающий конфиг и инициализирующий сценарий вашего
     типа на его основе.
   - Ридми для данного сценария `README.md` - здесь должен быть внешний вид
     и краткая инструкция по использованию

2. Добавить описание схемы webui для вашего нового сценария
   в файл `schema/scenarios.schema.json`

3. Файлы изображений для отображения схеме в формате png - положить рядом
   в папке `schema/*.png`

4. Если требуется поменять конфиг `wb-scenarios.conf` чтобы он корректно
   открывался в соответствии с вашими изменениями в схеме.
   В данный момент конфиг поставляется пустым, поэтому этот пункт
   можно опустить.

## Процесс разработки сценария

Общий процесс разарботки для WB описан тут:
- [Процесс разработки проектов Wiren Board](https://github.com/wirenboard/codestyle/blob/master/workflow.md)

Ниже описаны только шаги относящиеся именно к разработке сценариев:

Для разработки новый сценариев принят процесс инкрементальной разработки через
серию небольших PR в feature-ветку. Это обусловлено тем что:

- С одной стороны нельзя залить весь сценарий, так как даже мелкий сценарий
  состоит минимум из 4 файлов, который в общей сложности легко перевалят
  за 500 строк. Поэтому вливать все одним коммитом будет сложно проверяемо
  ревьюверами. А отдельно друг от друга файлы не являются полноценными
  функционильными частями которые будут работать самостоятельно.
- С другой стороны нельзя вливать сценарии в main итеррационно, например
  вливать в мастер по 1 полю каждый день будет плохой практикой, так как
  каждое такое изменение в версиях будет ломать конфиг пользователей.
  То есть - важно, что изменения в конфиге одного сценария повлекут
  за собой ошибку у пользователей. Поэтому добавление нового сценария
  не вызывает ошибок, но изменение схемы существующих сценариев - вызывает.

Суть метода

1. Сначала от мастера создается одна ветка feature
2. Далее уже от этой ветки feature создаются бранчи sub-feature, которые
   будут содержать маленькие инкрементальные изменения максимум размером:
   - Около 300-500 строк
   - 4-5 коммитов
3. Открываются поочередно мелкие PR для вливания кода из sub-feature в feature
4. После одобрения последнего PR из sub-feature в feature - код вливается
   в main ветку одним большим куском без дополнительных PR со стороны
   ревьюверов.

В итоге ревьюверам проще проверять каждый день по немногу, а в итоге в мейн
заливается уже маломальски готовая итерация которая не будет меняться часто.

### 1. Создать ветки

#### 1.1. Основная ветка `feature`

Создать ветки можно сразу в WEBUI github еще до того как вы клонируете
репозиторий - тогда далее будет меньше команд в консоли и ветка уже будет
создана на сервере.

Имя ветки должно состоять из:

- Начинается с `feature/` обозначая что это новый функционал
- Следом номер задачи в youtrack `INT-271`
- Далее что было добавлено, например `thermostat`

Например для добавления сценария термостата с задачей номер "INT-271" отражает
общий смысл большой задачи:

```text
feature/INT-271-thermostat/main
```

Обратите внимание что создать без main нельзя, это ограничение гита

```text
feature/INT-271-thermostat
```

После создания главной ветки по шаблону `feature/*/main` она становится
защищенной в настройках репозитория и пушить туда можно только после ревью.

#### 1.2. Ветка задачи `sub-feature`

Отражает смысл маленькой задачи:

Разделить общее название ветки и подзадачу нижним подчеркиванием чтобы было
понятно где начало названия задачи

```text
feature/INT-271-thermostat/create-dir-and-readme
```

### 2. Пуш первой версии

Для того чтобы разделить разработку на несколько PR - желательно делать
атомарные вливания которые проще отслеживать и проверять коллегам.

Для первого PR будет достаточно:

   1. Создать папку сценария
   2. Создать ридми где описать общий смысл сценария несколькими предложениями
   3. Запушить как первую пустую версию

Файл ридми не нужно расписывать подробно - цель данного PR просто обозначить
что файлы будут лежать в данной папке и ридми будет тут

Файл `README.md` может содержать примерно следующее

```markdown
# Сценарий термостата `thermostat`

Позволяет управлять нагревателями, например теплым полом
```

Далее в общем ридми добавить ссылку на описание нового сценария

```markdown
- [Термостат (нагрев)](scenarios/thermostat/README.md)
```

Ввести пояснение к коммиту

```text
docs: create new scenario dir + add README.md
```

Этот первый пуш нужен для

- Того чтобы оповестить всех кого нужно что идет разработка нового сценария
- Проверить названия веток, названия папок, название сценария и тд
- В ридми указать и обозначить примерно как это должно работать
- В общем ридми указать ссылку на созданный документ чтобы потом не забыть

#### Открыть PR

Так как PR в репозитории не разделяются по веткам, то имя PR должно содержать
намек на общую ветку и номер этого PR в порядке. Номер полезен если вы зальете
несколько PR ревьюверам будет понятно в каком порядке их смотреть.

```text
Thermostat: PR 1 - docs: create new scenario dir + add README.md
```

Описание

```Text
1. Создана папка для нового сценария термостата
2. Добавлен README.md файл с внешнего вида конфигуратора, принципа работы и тд
3. Добавлена ссылка на описание нового сценария в общий README.md в корне проекта
```

Когда этот PR одобряют - можно отправлять следующие PR.

### 3. Выбор порядка этапов разработки

Дальше есть несколько возможных подходов - выберете удобный вам, они в итоге
приводят к одному результату, но разные начальные точки и разные первые PR.

Разделил все три варианта от самого легкого новичкам к более трудным внизу.

- От схемы json
- От обычного скрипта
- От модуля

Когда уже есть опыт работы с json-editor, то удобнее всего создавать
сценарий начиная от схемы json. Этот подход позволяет сначала создать
и увидеть примерный WEBUI и что важно - видишь генерируемый выходной
конфиг который нужно парсить в скрипте инициализации.

Как следствие - быстро можно получить первый PR и сразу имеешь результат
в виде константного конфиг файла от которого можно уже строить логику скриптов

1. Модифицируем схему так как нужно для вашего сценария
2. Смотрим то что получается на выходе в конфиге
3. Пробрасываем в скрипт чтение конфига
4. Пишем простой скрипт
5. Выделяем логику инициализации в отдельный модуль

Профит - мы получили то что хотели идя от json схемы с переодическими
коммитами и плавным утверждением PR

### 4. Добавляем новый сценарий в схему

#### 4.1. В definitions добавляем описание

Раздел должен иметь уникальное название - в данном случае
это `"devicesControl"`
Далее идут стандартные описания раздела - титл и тд
Далее идет раздел properties - этот раздел содержит свойства данного сценария

1. В начале в любом сценарии должны всегда идти 4 стандартные поля
   - `scenarioType` - скрытое поле которое содержит тип данного сценария
   - `enable` - содержит настройку пользователя на счет того нужно
     ли генерировать правило для данного сценария
   - `name` - обязательное поле которое исопльзуется как в WEBUI
     для отображения сценария, так и в коде правил для задания
     заголовка виртуальномуустройству
   - `idPrefix` - необязательное поле.
     Указывает уникальный префикс, который будет использован при именовании
     создаваемых правил, виртуальных устройств и тд.
     По дефолту поле должно быть пустым, и если ничего не вводится
     пользователем, то префикс генерируется путем транслитерации из имени
     сценария.

2. Далее нужно описать кастомные поля для управления новым сценарием
   Примеры можно посмотреть в готовых сценариях

3. В конце идет `required` которое говорит какие поля должны быть заполнены
   перед сохранением

4. Отдельно отметим, что в `required` первым должен стоять в списке именно
   пункт "scenarioType" - так как именно по нему работает oneOf использующий
   опцию wb-multiple!

```json
        "devicesControl": {
            "type": "object",
            "title": "Light control",
            "description":"Данный сценарий предоставляет возможность управления светом с выключателей <br><img src=\"images/scenarios-link-in-to-out.png\">",
            "_format": "grid",
            "properties": {
                "scenarioType": {
                    "type": "string",
                    "enum": ["devicesControl"],
                    "default": "devicesControl",
                    "options": {
                        "hidden": true
                    }
                },
                "enable": {
                    "type": "boolean",
                    "title": "Enable",
                    "default": true,
                    "_format": "checkbox",
                    "propertyOrder": 1,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "name": {
                    "type": "string",
                    "title": "Scenario name",
                    "default": "Управление светом",
                    "minLength": 1,
                    "maxLength": 30,
                    "propertyOrder": 2,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "id_prefix": {
                    "type": "string",
                    "title": "ID Prefix",
                    "description": "Одно слово на английском языке исключая: пробел, /, +, #. Длина до 15 символов.",
                    "_pattern_comment": "Запрещает пробелы, /, +, и #, а также ограничивает строку использованием только цифр, нижнего подчеркивания и английских букв",
                    "pattern": "^[0-9a-zA-Z_]+$",
                    "default": "light_control",
                    "minLength": 1,
                    "maxLength": 15,
                    "propertyOrder": 3,
                    "options": {
                        "grid_columns": 12
                    }
                },
                ... Тут вставить кастомные поля ...
            },
            "required": ["scenarioType", "enable", "name", "id_prefix"]
        }
```

#### 4.2. Модифицировать oneOf

Добавить сверху

```json
"oneOf": [
    { "$ref": "#/definitions/linkInToOut" },
    { "$ref": "#/definitions/devicesControl" }
],
```

#### 4.3. Переводы

Внизу файла схемы нужно добавить переводы

### 5. Проверка

Проверить что все отображается как вы хотите

Сохранить конфиг и посмотреть что все сохранилось конкретно

При именовании полей желательно использовать слова намекающие
на тип - чтобы не только в схеме было понятно какого типа параметр,
но и в уже сохраненном конфиге.

Например:

- Для enum - вконце исопльзовать ...Type, например behaviorType
- Для числовых значений - ... value, например actionValue
- Для строковых сложно предусмотреть возможности, но например - ...Name,
  Path и тд указывая на то что содержится в параметре. Не просто mqttTopic,
  а mqttTopicName - явно указывает на строковый тип

### 6. Скрипт инициализации

Скрипт является точкой входа для сценария, так как при перезапуске wb-rules
именно с этого места начинается выполнение кода.

Данный скрипт должен открыть конфигурационный файл и инициализировать
все найденные сценарии с определенным типом.

Внутри нужно стараться использовать общие для всех сценариев интерфейсы
и структуру

Подключение файла модуля в переменную `scenarioModule`

```javascript
var scenarioModule = require('thermostat.mod');
```

Обобщенное имя переменной нужно чтобы дальше во всех сценариях
в коде можно было писать без изменений одну строчку инициализации

```javascript
var isInitSucess = thermostat.init(scenario.name, cfg);
```

Вся специфика модуля конкретного сценария должна быть спрятана внутри объекта
`cfg{}`.

### 7. Модуль

Модуль должен содержать всю логику сценария и запускать все правила для их
автономной работы после исполнения инициализации.

Прототип функции должен выглядеть следующим образом

```javascript
function init(deviceTitle, cfg) {
   ...
}
```

В конце файла модуля должен быть такой экспорт - одинаковый для всех
сценариев, так как все настройки специфичные для конкретного модуля должны
содержаться в объекте cfg{}:

```javascript
exports.init = function (deviceTitle, cfg) {
  var res = init(deviceTitle, cfg);
  return res;
};
```

Тут:

- `deviceTitle` - это отображаемое имя виртуального девайса который создается
  для управления сценарием. Данное имя только отображается для людей и не
  используется в MQTT на данный момент.
- `cfg` - это объект содержащий все настройки конкретного сценария
  и на данный момент имеет только одно обязательное поле `cfg.idPrefix`
  которое используется для добавления индивидуальных данных в виде префикса
  к правилам и виртуальным девайсам

Проверка входящих в функцию параметров:
Для того чтобы инициализировать правило мы должны быть уверены что
пользователь сконфтгурировал корректно работающую конфигурацию топиков
и выбранных событий и действий
Для этого нам нужно проверить:

- Что введённые пользователем устройства и топики существуют
  Проверку в некоторых случаях лучше не делать. Например wb-rules тоже не
  проверяет указываете ли вы существующие топики при создании правила.
  Проверка может привести к ошибке в вашем коде, но при этом девайс может
  создастся чуть позже или в вашем коде или просто в другом правиле wb-rules.
  В итоге проверка может привести к проблемме курицы и яйца, либо вынудит вас
  поменять в коде блоки порядком, что может привести к поломке логики файла.
  Данный момент с порядком создания можно попробовать решить введя задержку
  в создании правила выполнив его примерно через 2 секунды.

- Что тип выбранных пользователем топиков поддерживает выбранный
    тип события для аходных топиков или вид действия для выходных топиков

### 8. Заполнить `README.md` сценария

Когда уже понятен внешний вид и структура нового сценария - можно заполнить
документацию.

Внизу документа должна быть секция описывающая как можно инициализировать
модуль, название и два обязательных пункта:

```markdown
## Использование модуля

### Описание параметров конфигурации

...

### Пример использования

...
```

### 9. Добавить ссылку на сценарий в общий `README.md`

В корне проекта есть файл `README.md` в котором есть перечисление всех
реализованных сценариев. Нужно добавить ссылку на новый сценарий в этот
список:

```markdown
На данный момент реализованы сценарии:

- [Управление устройствами](scenarios/devices-control/README.md)
- [Управление светом](scenarios/light-control/README.md)
- [Термостат (нагрев)](scenarios/thermostat/README.md)
- ... Сюда добавить новый сценарий ...
```

### 10. Увеличить версию пакета

При заливании в мастер нужно обязательно увеличить версию, это нужно сделать
добавив запись в ченжлог файл `debian\changelog`.

Пример добавленной записи - обратите на версию внутри скобок 1.1.1 - она
должна отличаться от предыдушей записи в большую сторону:

```changelog
wb-scenarios (1.1.1) stable; urgency=medium

  * feat: implement base version for new scenario "thermostat"

 -- Ivan Ivanov <ivan.ivanov@wirenboard.com>  Fri, 24 Jan 2024 10:00:00 +0300
```

### 9. Ревью

Пройти ревью и в конце сделать слияние с предварительным соединением всех
коммитов в ветке в один коммит - то есть нажать именно "Sqash and merge" а
не просто "Create a merge commit"

## Другие варианты порядка разработки

Так же можно разрабатывать начиная с других элементов:

- От модуля
- От обычного скрипта

### От модуля

Самый сложный и абстрактный путь самурая которому не нужны никакая
опора под ногами для работы. Модуль сам по себе является опциональной
единицей разделения фукнционала и не обязателен для работы сценариев.
Сразу пишем модуль, интегрируем его в скрипт который считывает конфиг.
Здесь мало переделок, много параллельной взаимосвязанной работы и видимый
результат виден только в конце.

### От скрипта инициализации

Удобно использовать новичкам в первый раз - когда не знаешь еше окружения
и не работал с json-editor.
Путь начинается от обычного скрипта wb-rules и заканчивается интеграцией
решения в json-editor.

1. Написание обычного скрипта
   На данном этапе нужно написать скрипт который статично выполнит
   то что вы хотите сделать без обработок ошибок - просто в лоб.

2. Разделить этот скрипт вытащив либо переменные в webui,
   либо написав сначала модуль

3. Дописать оставшуюся часть

## Библиотека сценариев

При разработке сценариев были разработаны и используются стандартные фукнции
и сущности которые могут помочь при разработке нового сценария.

Стандартный сценарий представляет из себя

- Массив входных топиков которые отслеживаются
- Специфичную логику преобразования для данного сценария
- Массив выходных топиков которым нужно изменить состояние

Есть два варианта блоков которые имеют уже написанные способы обработки
и прокидывания значений enum в код.

1. Массив источников событий
   - Обработчик анализирующий причину события
2. Девайсы для воздействия
   - Обработчик выставляющий нужные значения каждому выходному контролу
     в зависимости от выбранного типа поведения (поменять, выставить
     в выключенное состояине и тд)

У обоих типов есть свои предопределенные типы поведений которые может выбрать
пользователь, либо определить разработчик.

Выбранные enum будут определять как данный контрол будет обрабатываться
фукнцией setAll...

Если вам не нужно поле выбора и для сценария предпологается запуск
действий всегда по одному типу поведения - например отслеживается только
увеличение значения счетчика, как у кнопок без фиксации - то вы можете
добавить опцию hide чтобы скрыть поле выбора и установить нужный тип
триггера данному массиву. Тогда любой контрол добавленный в ваш массив
будет проверен на данный вид изменения, после чего будет запущена логика
в кастомном правиле которое вы опишите.
