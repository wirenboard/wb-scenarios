# Документация для разработчиков

В данном файле описано все что нужно знать для разработки
новых сценариев для WB с нуля.

Информация по другим аспектам работы со сценариями собрана тут:

1) [Пример добавления сценария](example-add-new-scenario.md)
2) [Описание используемого стиля и окружения](environment-guide.md)
   Обязательно использовать форматтер prettier, чтобы следить за форматом кода
   По желанию можно использовать линтер ESLint, чтобы подсвечивать ошибки
3) [Варианты установки и сборки сценариев](install-variants-and-build-pkg.md)

## Общее о сценариях

Сценарии являются методом упрощения конфигурирования контроллера WB.
Они позволяют настраивать работу частых юзкейсов через графический интерфейс
без необходимости изучения написания скриптов.

Сценарии состоят из следующих составляющих:

1. Описание WEBUI в виде схемы json-editor: `*.schema.json`
   При необходимости изображения `*.png`

2. Сохраненный конфиг, из вебки в виде автогенерируемой из схемы json структуры: `*.conf`

3. Модуль сценария `*.mod.js`
   Содержит класс сценария, наследующий от ScenarioBase:
   - Реализация методов generateNames(), validateCfg(), initSpecific()
   - Логика создания правил и обработчиков событий
   - Управление виртуальным устройством сценария

4. Модуль инициализации `scenario-init-*.mod.js`
   Точка входа для инициализации сценариев данного типа:
   - Чтение конфигурации из файла
   - Фильтрация сценариев по типу
   - Создание экземпляров сценариев и их инициализация

   ВАЖНО - модуль сценария должен наследоваться от ScenarioBase и следовать
   единой архитектуре:
   - Реализовывать обязательные методы: generateNames(), validateCfg(), initSpecific()
   - Использовать централизованную инициализацию через scenario-init-main.js
   - Следовать паттернам управления состоянием и виртуальными устройствами

Ниже описывается процесс создания новых сценариев

## Добавление нового сценария

Для добавления нового сценария нужно выполнить несколько шагов:

1) Создать в папке `scenarios` подпапку с именем вашего сценария.
   Имя маленькими латинскими буквами через тире, например `link-in-to-out`
   Тут хранятся файлы относяшиеся к конкретному сценарию:

   - Модуль сценария `<name>.mod.js` с классом, наследующим от ScenarioBase
   - Модуль инициализации `scenario-init-<name>.mod.js` для данного типа сценария
   - README для данного сценария `README.md` - здесь должен быть внешний вид
     и краткая инструкция по использованию

2) Добавить описание схемы webui для вашего нового сценария
   в файл `schema/scenarios.schema.json`

3) Файлы изображений для отображения схеме в формате png - положить рядом
   в папке `schema/*.png`

4) Если требуется поменять конфиг `wb-scenarios.conf` чтобы он корректно
   открывался в соответствии с вашими изменениями в схеме.
   В данный момент конфиг поставляется пустым, поэтому этот пункт
   можно опустить.

**Подробная пошаговая инструкция с примерами:** [example-add-new-scenario.md](example-add-new-scenario.md)

## Процесс разработки сценария

1. Пуш первой версии
   1. Создать папку
   2. Создать ридми где описать общий смысл сценария
   3. Создать файл скрипта с шаблоном
   4. Запушить как первую пустую версию

Дальше есть несколько возможных подходов - выберете удобный вам, они в итоге
приводят к одному результату, но разные начальные точки и разные первые PR.

Разделил все три варианта от самого легкого новичкам к более трудным внизу.

Удобно создавать сценарий начиная от схемы json. Этот подход позволяет сначала
создать и увидеть примерный WEBUI и что важно - видишь генерируемый выходной
конфиг который нужно парсить в скрипте инициализации.

Как следствие - быстро можно получить первый PR и сразу имеешь результат
в виде константного конфиг файла от которого можно уже строить логику скриптов

1. Модифицируем схему так как нужно для вашего сценария
2. Смотрим то что получается на выходе в конфиге
3. Пробрасываем в скрипт чтение конфига
4. Пишем простой скрипт
5. Выделяем логику инициализации в отдельный модуль

Профит - мы получили то что хотели идя от json схемы с переодическими
коммитами и плавным утверждением PR

### 1. Добавляем новый сценарий в схему (из example-add-new-scenario.md)

#### 1.1. В definitions добавляем описание

Раздел должен иметь уникальное название - в данном случае
это `"linkInToOut"` (используйте то же имя, что и в `scenarioTypeStr`)
Далее идут стандартные описания раздела - титл и тд
Далее идет раздел properties - этот раздел содержит свойства данного сценария

1) В начале в любом сценарии должны всегда идти 4 стандартные поля
   - scenarioType
   - enable
   - name
   - id_prefix
2) Далее нужно описать кастомные поля для управления новым сценарием
   Примеры можно посмотреть в готовых сценариях
3) В конце идет `required` которое говорит какие поля должны быть заполнены
   перед сохранением

```json
        "linkInToOut": {
            "type": "object",
            "title": "Link Input to Output",
            "description":"Данный сценарий связывает входной контрол с выходным с возможностью инверсии",
            "_format": "grid",
            "properties": {
                "scenarioType": {
                    "type": "string",
                    "enum": ["linkInToOut"],
                    "default": "linkInToOut",
                    "options": {
                        "hidden": true
                    }
                },
                "enable": {
                    "type": "boolean",
                    "title": "Enable",
                    "default": true,
                    "_format": "checkbox",
                    "propertyOrder": 1,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "name": {
                    "type": "string",
                    "title": "Scenario name",
                    "default": "Link Input to Output",
                    "minLength": 1,
                    "maxLength": 30,
                    "propertyOrder": 2,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "id_prefix": {
                    "type": "string",
                    "title": "ID Prefix",
                    "description": "Одно слово на английском языке исключая: пробел, /, +, #. Длина до 15 символов.",
                    "_pattern_comment": "Запрещает пробелы, /, +, и #, а также ограничивает строку использованием только цифр, нижнего подчеркивания и английских букв",
                    "pattern": "^[0-9a-zA-Z_]+$",
                    "default": "link_in_to_out",
                    "minLength": 1,
                    "maxLength": 15,
                    "propertyOrder": 3,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "inControl": {
                    "type": "string",
                    "title": "Input Control",
                    "description": "MQTT topic для входного контрола (device/control)",
                    "propertyOrder": 4,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "outControl": {
                    "type": "string", 
                    "title": "Output Control",
                    "description": "MQTT topic для выходного контрола (device/control)",
                    "propertyOrder": 5,
                    "options": {
                        "grid_columns": 12
                    }
                },
                "inverseLink": {
                    "type": "boolean",
                    "title": "Inverse Signal",
                    "description": "Инвертировать сигнал при передаче с входа на выход",
                    "default": false,
                    "_format": "checkbox",
                    "propertyOrder": 6,
                    "options": {
                        "grid_columns": 12
                    }
                },
                ... Тут вставить кастомные поля ...
            },
            "required": ["scenarioType", "enable", "name", "id_prefix", "inControl", "outControl"]
        }
```

#### 1.2. Модифицировать oneOf

Добавить сверху

```json
"oneOf": [
    { "$ref": "#/definitions/linkInToOut" },
    { "$ref": "#/definitions/devicesControl" }
],
```

#### 1.3. Переводы

Внизу файла схемы нужно добавить переводы

### 2. Проверка

Проверить что все отображается как вы хотите

Сохранить конфиг и посмотреть что все сохранилось конкретно

При именовании полей желательно использовать слова намекающие
на тип - чтобы не только в схеме было понятно какого типа параметр,
но и в уже сохраненном конфиге.

Например:

- Для enum - вконце исопльзовать ...Type, например behaviorType
- Для числовых значений - ... value, например actionValue
- Для строковых сложно предусмотреть возможности, но например - ...Name,
  Path и тд указывая на то что содержится в параметре. Не просто mqttTopic,
  а mqttTopicName - явно указывает на строковый тип

### 3. Модуль инициализации

Модуль инициализации является точкой входа для сценариев определенного типа.
Он подключается в `scenarios/scenario-init-main.js` и выполняется при старте wb-rules.

Данный модуль должен:
- Прочитать конфигурационный файл `/etc/wb-scenarios.conf`
- Отфильтровать сценарии нужного типа
- Создать экземпляры класса сценария для каждого найденного сценария
- Инициализировать их через метод `init()`

Пример структуры модуля инициализации:
```javascript
var CFG = {
  scenarioTypeStr: 'linkInToOut',  // Тип сценария
  reqVerScenario: 1,               // Требуемая версия
};

function initializeScenario(scenarioCfg) {
  var scenario = new YourScenarioClass();
  var cfg = {
    idPrefix: scenarioCfg.id_prefix,
    // ... другие поля из scenarioCfg
  };
  
  // Вызов init() происходит здесь, в модуле инициализации
  var isBasicVdCreated = scenario.init(scenarioCfg.name, cfg);
  if (isBasicVdCreated !== true) {
    log.error('Virtual device creation failed');
    return;
  }
}

function setup() {
  // Логика чтения конфига и инициализации всех сценариев типа
}
```

### 4. Модуль сценария

Модуль сценария должен содержать класс, наследующий от ScenarioBase.
Класс должен реализовать три обязательных метода:

```javascript
function YourScenarioClass() {
  ScenarioBase.call(this);
  // Инициализация свойств класса
}

YourScenarioClass.prototype = Object.create(ScenarioBase.prototype);
YourScenarioClass.prototype.constructor = YourScenarioClass;

// Обязательные методы:
YourScenarioClass.prototype.generateNames = function(idPrefix) {
  // Генерация имен для VD и правил
  return { vDevice: 'name', rule1: 'rule_name' };
};

YourScenarioClass.prototype.validateCfg = function(cfg) {
  // Валидация конфигурации
  return true; // или false при ошибке
};

YourScenarioClass.prototype.initSpecific = function(name, cfg) {
  // Специфичная инициализация сценария
  // Создание правил, сохранение параметров
  return true; // или false при ошибке
};
```

Проверка конфигурации:
ScenarioBase автоматически вызывает метод `validateCfg()` перед инициализацией.
В этом методе нужно проверить:

- Корректность обязательных полей конфигурации
- Существование указанных устройств и контролов
- Совместимость типов контролов с логикой сценария

Если `validateCfg()` вернет `false`, сценарий перейдет в состояние 
`ScenarioState.CONFIG_INVALID` и будет отключен.

Дополнительно можно использовать метод `defineControlsWaitConfig()` для 
указания контролов, которые должны быть готовы перед началом инициализации:

```javascript
YourScenarioClass.prototype.defineControlsWaitConfig = function(cfg) {
  return {
    controls: [cfg.inControl, cfg.outControl],
    timeout: 10000  // опционально
  };
};
```

### Другие варианты порядка разработки

Так же можно разрабатывать начиная с других элементов:

- От модуля
- От обычного скрипта

#### От модуля

Самый сложный и абстрактный путь самурая которому не нужны никакая
опора под ногами для работы. Модуль сам по себе является опциональной
единицей разделения фукнционала и не обязателен для работы сценариев.
Сразу пишем модуль, интегрируем его в скрипт который считывает конфиг.
Здесь мало переделок, много параллельной взаимосвязанной работы и видимый
результат виден только в конце.

#### От модуля инициализации

Удобно использовать новичкам в первый раз - когда не знаешь еше окружения
и не работал с json-editor.
Путь начинается от обычного скрипта wb-rules и заканчивается интеграцией
решения в json-editor.

1. Написание обычного скрипта
   На данном этапе нужно написать скрипт который статично выполнит
   то что вы хотите сделать без обработок ошибок - просто в лоб.

2. Разделить этот скрипт вытащив либо переменные в webui,
   либо написав сначала модуль

3. Дописать оставшуюся часть

## Архитектура сценариев

Все сценарии основаны на единой архитектуре ScenarioBase, которая предоставляет:

### Базовые компоненты:
- **ScenarioBase** - базовый класс для всех сценариев (src/wbsc-scenario-base.mod.js)
- **ScenarioState** - состояния сценария (src/virtual-device-helpers.mod.js)  
- **Logger** - система логирования (src/logger.mod.js)
- **scenarios-general-helpers** - общие вспомогательные функции

### ScenarioBase - обязательные методы для наследников:

#### **ОБЯЗАТЕЛЬНЫЕ МЕТОДЫ**:

1. **`generateNames(idPrefix)`** - генерирует имена для VD и правил
   ```javascript
   YourScenario.prototype.generateNames = function(idPrefix) {
     return {
       vDevice: 'wbsc_' + idPrefix,
       ruleInput: 'wbsc_' + idPrefix + '_input',
       // ... другие имена
     };
   };
   ```

2. **`validateCfg(cfg)`** - валидирует конфигурацию перед инициализацией
   ```javascript
   YourScenario.prototype.validateCfg = function(cfg) {
     if (!cfg.requiredField) {
       log.error('Missing required field');
       return false;
     }
     return true;
   };
   ```

3. **`initSpecific(name, cfg)`** - специфичная инициализация сценария
   ```javascript
   YourScenario.prototype.initSpecific = function(name, cfg) {
     // Создание правил, сохранение параметров
     // Использовать this.addRule(ruleId) для сохранения ID правил
     this.setState(ScenarioState.NORMAL);
     return true;
   };
   ```

#### **НЕОБЯЗАТЕЛЬНЫЕ МЕТОДЫ**:

4. **`defineControlsWaitConfig(cfg)`** - настройка ожидания контролов
   ```javascript
   YourScenario.prototype.defineControlsWaitConfig = function(cfg) {
     return {
       controls: [cfg.inputControl, cfg.outputControl],
       timeout: 10000,  // опционально, мс
       period: 500      // опционально, мс
     };
   };
   ```

#### **ДОСТУПНЫЕ МЕТОДЫ** базового класса:

- **`getState()`** - получить текущее состояние сценария
- **`setState(stateCode)`** - установить состояние сценария
- **`addRule(ruleId)`** - сохранить ID правила
- **`enable()`** - включить все правила сценария
- **`disable()`** - отключить все правила сценария
- **`init(name, cfg)`** - основной метод инициализации (НЕ переопределять без особой необходимости!)

### Стандартная структура сценария:
- Класс сценария, наследующий от ScenarioBase
- Виртуальное устройство для управления и отображения состояния  
- Правила wb-rules для обработки событий
- Система валидации конфигурации и ожидания готовности контролов

### Жизненный цикл сценария:
1. **CREATED** (0) - сценарий создан, начальное состояние
2. **INIT_STARTED** (1) - началась инициализация базового класса
3. **WAITING_CONTROLS** (2) - ожидание готовности контролов из `defineControlsWaitConfig()`
4. **LINKED_CONTROLS_READY** (3) - все необходимые контролы готовы к использованию
5. **CONFIG_INVALID** (4) - ошибка валидации конфигурации в `validateCfg()`
6. **LINKED_CONTROLS_TIMEOUT** (5) - таймаут ожидания готовности контролов
7. **NORMAL** (6) - сценарий работает нормально, основное рабочее состояние
8. **USED_CONTROL_ERROR** (7) - ошибка при работе с контролами во время выполнения

### Доступные вспомогательные модули:

1) **virtual-device-helpers.mod.js**
   - Создание базовых виртуальных устройств
   - Управление состояниями сценариев
   - Проверка существования контролов

2) **scenarios-general-helpers.mod.js**
   - Чтение и валидация конфигурации
   - Генерация ID префиксов
   - Глобальное хранилище сценариев

3) **wbsc-wait-controls.mod.js**
   - Ожидание готовности контролов перед инициализацией
   - Обработка таймаутов

4) **logger.mod.js**
   - Унифицированная система логирования
   - Уровни логирования и форматирование
